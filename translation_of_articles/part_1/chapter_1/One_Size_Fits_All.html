<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>One Size Fits All Kirill Dikalin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../../css/style.css">
  <link rel="stylesheet" href="../../../translation_of_articles/tr_css.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/monokai-sublime.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <link rel="icon" href="https://2.downloader.disk.yandex.ru/preview/3c43a29645dc1cb6fb78199deb365f46e061775e3ee31ba65584457a9f192b86/inf/AbjxdUaE_6Aa7Fn6v8jR0U2p3VzUdMbJwk71Pp3daxwLsMD2Wm8xbpJK_TRwJbHaFO-M69wK77--4JS56fnQkA%3D%3D?uid=387842181&filename=favicon.ico&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=387842181&tknv=v2&size=1920x980" type="image/x-icon">
</head>

<body>
  <ul class="breadcrumb">
    <a class="bread_crumb" href="../../../index.html">Kirill Dikalin</a> / <a href="../../../translation_of_articles/translation_of_articles.html" class="project"> Перевод статей</a> / <a class="bread_crumb" href="../chapter_1/Bibliography_1_1.html">Библиография, Глава 1, Часть 1</a> / One Size Fits All
  </ul>

  <h1 style="padding-top: 1em;">One Size Fits All / «Один размер подходит всем»</h1>
  
  <div class="our_framework">
    <div class="section_content">
      <div id="toc_container">

        <ul>
          <li class="toc_section"><a href="https://disk.yandex.ru/i/hcKW9xqdatE_Vw" class="intext">Оригинал статьи</a></li>
        </ul>
        
        <h1 style="padding-top: 1em;"> Оглавление </h1>
          <ul>
            <li class="toc_section"><a class="intext">Аннотация</a>
            <li class="toc_section"><a class="intext">1. Введение</a>
            <li class="toc_section"><a class="intext">2. Хранилище данных</a>
            <li class="toc_section"><a class="intext">3. Потоковая обработка</a>
              <ul>
                <li><a class="intext">3.1 Новые сенсорные приложения</a>
                <li><a class="intext">3.2 Существующее приложение: обработка финансовых потоков</a>
              </ul>
            </li>
            <li><a class="toc_section" class="intext">4. Обсуждение производительности</a>
              <ul>
                <li><a class="intext">4.1 «Входящая» и «исходящая» обработка</a>
                <li><a class="intext">4.2 Правильные примитивы</a>
                <li><a class="intext">4.3 Полная интеграция обработки СУБД и логики приложения</a>
                <li><a class="intext">4.4 Высокая доступность</a>
                <li><a class="intext">4.5 Синхронизация</a>
              </ul>
            </li>
            <li><a class="toc_section" class="intext">5. Один размер подходит всем?</a>
              <ul>
                <li><a class="intext">5.1 Хранилища данных</a></li>
                <li><a class="intext">5.2 Сенсорные сети</a></li>
                <li><a class="intext">5.3 Текстовый поиск</a></li>
                <li><a class="intext">5.4 Научные базы данных</a></li>
                <li><a class="intext">5.5 Базы данных XML</a></li>
              </ul>
            </li> 
            <li class="toc_section"><a>6. Комментарий по факторингу</a></li>
            <li class="toc_section"><a>7. Заключительные замечания </a></li>         
          </ul>
        </div>
      </div>
      
      <div class="section_name">
        Аннотация
      </div>
      <p align="justify" class="p_on_project_pages">
        Последние 25 лет разработки коммерческих СУБД можно суммировать одной фразой: «Один размер подходит всем». 
        Эта фраза относится к тому факту, что традиционная архитектура СУБД (изначально разработанная и оптимизированная 
        для обработки бизнес-данных) использовалась для поддержки множества ориентированных на данные. 
        В этой статье мы утверждаем, что эта концепция не применима в течение длительного времени к рынку баз 
        данных и что коммерческий мир распадется на набор независимых механизмов баз данных, некоторые из 
        которых могут быть объединены с помощью общего интерфейсного анализатора. Чтобы подкрепить наши утверждения, 
        мы используем примеры с рынка потоковой обработки и рынка хранилищ данных. Мы также вкратце обсудим 
        другие рынки, для которых традиционная архитектура не подходит, и выступим за критическое переосмысление 
        текущего факторинга системных услуг в продукты.
      </p>
      <div class="section_name">
        1. Введение
      </div>
      <p align="justify" class="p_on_project_pages">
        Реляционные СУБД появились в качестве исследовательских прототипов в 1970-х годах в форме System R и 
        INGRES. Основная цель обоих прототипов заключалась в том, чтобы превзойти IMS по ценности для клиентов 
        в приложениях, для которых IMS использовалась, а именно в «обработке бизнес-данных». Следовательно, обе 
        системы были спроектированы для приложений онлайн-обработки транзакций (OLTP), а их коммерческие аналоги 
        (то есть, DB2 и INGRES, соответственно) нашли признание на этой арене в 1980-х годах. Другие поставщики (например, 
        Sybase, Oracle и Informix) следовали той же базовой модели СУБД, которая хранит реляционные таблицы построчно, 
        использует B-деревья для индексации, использует оптимизатор на основе затрат и предоставляет свойства 
        транзакций ACID. С начала 1980-х годов основные поставщики СУБД неуклонно придерживались стратегии «один размер 
        подходит всем», в соответствии с которой они поддерживают единую строку кода со всеми службами СУБД. Причины 
        этого выбора просты использование нескольких строк кода вызывает различные практические проблемы, включая:
      </p>
      <ul>
        <li><a>проблему стоимости, потому что затраты на обслуживание увеличиваются, по крайней мере, линейно с количеством строк кода;</a>
        <li><a>проблему совместимости, потому что все приложения должны работать с каждой строкой кода;</a>
        <li><a>проблему продаж, потому что продавцы не понимают, какой продукт попробовать продать покупателю;</a>
        <li><a>маркетинговую проблему, потому что несколько строк кода должны быть правильно позиционированы на рынке.</a>
      </ul>
      <p align="justify" class="p_on_project_pages">
        Чтобы избежать этих проблем, все основные поставщики СУБД следовали поговорке «кладите все дрова на одну головку». 
        В этой статье мы утверждаем, что эта стратегия уже потерпела неудачу и потерпит неудачу еще более резко в будущем.
      </p>
      <p align="justify" class="p_on_project_pages">
        Остальная часть статьи структурирована следующим образом. В Разделе 2 мы кратко указываем, почему стратегия единой 
        кодовой строки уже потерпела неудачу, цитируя некоторые ключевые характеристики рынка хранилищ данных. В Разделе 3 мы 
        обсуждаем приложения потоковой обработки и указываем конкретный пример, в котором специализированный механизм потоковой
        обработки превосходит РСУБД на два порядка. Затем в разделе 4 рассматриваются причины разницы в производительности и
        указывается, что технология СУБД вряд ли сможет адаптироваться, чтобы стать конкурентоспособной на этом рынке. 
        Следовательно, мы ожидаем, что движки потоковой обработки будут процветать на рынке. В Разделе 5 мы обсуждаем ряд 
        других рынков, на которых один размер вряд ли подходит для всех, и могут быть применимы другие специализированные 
        системы баз данных. Следовательно, фрагментация рынка СУБД может быть довольно обширной. В Разделе 6 мы предлагаем 
        некоторые комментарии по поводу включения системного программного обеспечения в продукты. Наконец, мы завершаем статью 
        некоторыми заключительными замечаниями в разделе 7.
      </p>
      <div class="section_name">
       2. Хранилище данных
      </div>
      <p align="justify" class="p_on_project_pages">
        В начале 1990-х годов появилась новая тенденция: предприятия захотели собрать вместе данные из нескольких операционных 
        баз данных в хранилище данных для целей бизнес-аналитики. Типичное крупное предприятие имеет около 50 операционных систем, 
        каждая из которых имеет онлайн-сообщество пользователей, ожидающих быстрого реагирования. Системные администраторы 
        неохотно допускали (и продолжают) разрешать пользователям бизнес-аналитики пользоваться одними и теми же системами,
        опасаясь, что сложные специальные запросы от этих пользователей уменьшат время отклика для онлайн-сообщества. Кроме того, 
        пользователи бизнес-аналитики часто хотят видеть исторические тенденции, а также сопоставлять данные из нескольких 
        операционных баз данных. Эти функции сильно отличаются от тех, которые требуются онлайн-пользователям.
      </p>
      <p align="justify" class="p_on_project_pages">
        По этим причинам практически каждое предприятие создавало большое хранилище данных и периодически «копировало» в него данные 
        из операционных систем. После этого пользователи бизнес-аналитики могли запускать свои сложные специальные запросы к данным в 
        хранилище, не затрагивая онлайн-пользователей. Хотя большинство складских проектов значительно превышали бюджет и в итоге 
        предоставляли только часть обещанной функциональности, они все же обеспечивали разумную окупаемость инвестиций. Фактически, 
        широко признано, что исторические склады розничных операций окупаются в течение года, прежде всего в результате более осознанного 
        оборота запасов и решений о покупке. Например, пользователь бизнес-аналитики может обнаружить, что камни для домашних животных
        отсутствуют, а куклы Барби находятся внутри, а затем принять соответствующие решения о размещении товаров и покупке.
      </p>
      <p align="justify" class="p_on_project_pages">
        Хранилища данных сильно отличаются от систем OLTP. Системы OLTP оптимизированы для обновлений, так как основной бизнес-деятельностью 
        обычно является продажа товара или услуги. Напротив, основная деятельность в хранилищах данных это специальные запросы, которые часто 
        бывают довольно сложными. Следовательно, периодическая загрузка новых данных, перемежающаяся со специальными запросами, это то, 
        что испытывает типичное хранилище.
      </p>
      <p align="justify" class="p_on_project_pages">
        Стандартная мудрость в схемах хранилищ данных создать таблицу фактов, содержащую «кто, что, когда, где» о каждой операционной 
        транзакции. Например, на рисунке 1 показана схема типичного продавца. Обратите внимание на центральную таблицу фактов, в 
        которой содержится запись для каждого товара, сканируемого кассиром в каждом магазине в его сети. Кроме того, склад содержит 
        таблицы измерений с информацией о каждом магазине, каждом клиенте, каждом продукте и каждом периоде времени. Фактически 
        таблица фактов содержит внешний ключ для каждого из этих измерений, и естественным результатом является звездообразная схема. 
        Такие звездообразные схемы повсеместно присутствуют в средах хранилищ, но практически отсутствуют в средах OLTP.
      </p>
      <p align="justify" class="p_on_project_pages">
        Хорошо известно, что приложения хранилища работают намного лучше, используя индексы битовых карт, в то время как пользователи 
        OLTP предпочитают индексы B-дерева. Причины просты: растровые индексы быстрее и компактнее для рабочих нагрузок хранилища, но 
        не работают в средах OLTP. В результате многие поставщики поддерживают как индексы B-дерева, так и индексы битовых карт в своих СУБД.
      </p>
      <p align="justify" class="p_on_project_pages">
        Кроме того, материализованные представления полезная тактика оптимизации в мирах складов, но никогда в мирах OLTP. Напротив, 
        обычные («виртуальные») представления находят признание в средах OLTP.
      </p>
      <p align="justify" class="p_on_project_pages">
        В первом приближении у большинства поставщиков есть СУБД хранилища (индексы битовых карт, материализованные представления, 
        звездообразные схемы и тактика оптимизатора для запросов звездообразной схемы) и СУБД OLTP (индексы B-дерева и стандартный 
        оптимизатор на основе затрат), которые объединены общим синтаксическим анализатором, как показано на рисунке 6.
      </p>
      <p align="justify" class="p_on_project_pages">
        Хотя такая конфигурация позволяет такому поставщику продавать свою СУБД как единую систему, из-за единого пользовательского 
        интерфейса, по сути, он продает несколько систем. Более того, как рынок OLTP, так и рынок складских услуг будут оказывать 
        значительное давление в отношении функций, которые не используются в других странах. Например, в базах данных OLTP обычной 
        практикой является представление части адреса (в США) в виде двухбайтовой символьной строки. Напротив, очевидно, что 50 состояний 
        могут быть закодированы в шесть битов. Если имеется достаточно запросов и данных, чтобы оправдать затраты на кодирование поля 
        состояния, то более позднее представление является предпочтительным. Обычно это верно для складов и никогда не верно для 
        OLTP. Следовательно, сложное кодирование полей будет функцией хранилища, которая практически не используется в OLTP. Включение 
        дополнительных специфичных для рынка функций сделает коммерческие продукты все более похожими на архитектуру, показанную на 
        Рисунке 6.
      </p>
      <p align="justify" class="p_on_project_pages">
        Иллюзия «универсальности для всех» может быть сохранена как маркетинговая фикция для двух разных систем, показанных на Рисунке 6, 
        благодаря общему пользовательскому интерфейсу. На рынке потоковой обработки, к которому мы сейчас переходим, такой общий 
        интерфейс нецелесообразен. Следовательно, будут не только разные двигатели, но и разные передние части. Маркетинговая фикция 
        «всех под одну гребенку» никуда не годится.
      </p>
      <div class="section_name">
        3. Потоковая обработка
      </div>
      <p align="justify" class="p_on_project_pages">
        В последнее время в исследовательском сообществе наблюдается значительный интерес к приложениям обработки потоковой информации.
        Этот интерес мотивирован предстоящей коммерческой жизнеспособностью сенсорных сетей в ближайшие несколько лет.
        Хотя RFID в последнее время привлекла внимание прессы и найдет широкое распространение в розничных приложениях, связанных с 
        оптимизацией цепочки поставок, существует также множество других технологий (например, Lojack). Многие отраслевые 
        эксперты видят «зеленое поле» для приложений мониторинга, которое станет возможным благодаря этому «коренному изменению», 
        вызванному сетями недорогих сенсорных устройств.
      </p>
      <div class="subsection_name">
        3.1 Новые сенсорные приложения
      </div>
      <p align="justify" class="p_on_project_pages">
        Существуют очевидные применения технологии сенсорных сетей в военной сфере. Например, армия США изучает возможность установки 
        мониторов жизненно важных функций на всех солдат, чтобы они могли оптимизировать медицинскую сортировку в боевых ситуациях. 
        Кроме того, во многих военных транспортных средствах уже есть система GPS, но она еще не подключена к замкнутой системе. 
        Вместо этого армия хотела бы отслеживать положение всех транспортных средств и определять в режиме реального времени, сбились 
        ли они с курса. Кроме того, они хотели бы датчик на башне орудия; вместе с местоположением это позволит обнаруживать ситуации 
        перекрестного огня. Датчик на манометре позволит оптимизировать заправку. В целом, армейский батальон из 30 000 человек и 
        12 000 транспортных средств скоро станет крупномасштабной сенсорной сетью из нескольких сотен тысяч узлов, доставляющих информацию 
        о состоянии и местоположении в режиме реального времени.
      </p>
      <p align="justify" class="p_on_project_pages">
        Узлы обработки в сети и нижестоящие серверы должны иметь возможность работать с этим «пожарным шлангом» данных. Обязательные 
        операции включают сложное оповещение, например, командир взвода хочет знать, когда три из его четырех машин пересекают линию 
        фронта. Также требуются исторические запросы, такие как «Где было транспортное средство 12 последние два часа?» Наконец, 
        требования включают продольные запросы, такие как «Каково общее состояние готовности сил на данный момент?»
      </p>
      <p align="justify" class="p_on_project_pages">
        Другие приложения для мониторинга на основе датчиков также появятся со временем во многих невоенных приложениях. Один из примеров 
        мониторинг пробок на дорогах и предложение альтернативных маршрутов. Связанное с этим приложение это изменяемая, основанная 
        на заторах система взимания платы за дорожные сети, которая послужила источником вдохновения для эталонного теста Linear Road. 
        Парки развлечений скоро превратят пассивные браслеты клиентов в активные датчики, чтобы можно было оптимизировать аттракционы и 
        определять местонахождение потерянных детей. Сотовые телефоны уже являются активными устройствами, и легко представить себе услугу, 
        с помощью которой можно найти ближайший ресторан к голодному покупателю. Даже библиотечные книги будут помечены датчиками, потому 
        что, если одна из них будет неправильно поставлена на полку, она может навсегда потеряться в большой библиотеке.
      </p>
      <p align="justify" class="p_on_project_pages">
        Существует широко распространенное предположение, что обычные СУБД не будут хорошо работать с этим новым классом приложений для 
        мониторинга. Фактически, на Linear Road традиционные решения почти на порядок медленнее, чем специализированный движок потоковой 
        обработки. Неприменимость традиционной технологии СУБД к потоковым приложениям также подтверждается исследованием текущих 
        областей приложений с потоковыми данными. Теперь мы обсудим наш опыт работы с таким приложением обработкой финансовых потоков.
      </p>
      <div class="subsection_name">
        3.2 Существующее приложение: обработка финансовых потоков
      </div>
      <p align="justify" class="p_on_project_pages">
        Большинство крупных финансовых учреждений подписываются на каналы, которые предоставляют данные о рыночной активности в режиме 
        реального времени, в частности новости, завершенные сделки, заявки и запросы и т. Д. Reuters, Bloomberg и Infodyne являются 
        примерами поставщиков, предоставляющих такие каналы. У финансовых учреждений есть множество приложений, обрабатывающих такие 
        потоки. К ним относятся системы, которые производят бизнес-аналитику в реальном времени, те, которые выполняют электронную 
        торговлю, те, которые обеспечивают юридическое соответствие всех сделок различным компаниям и правилам SEC, и те, которые 
        вычисляют в реальном времени риск и подверженность рынка колебаниям валютных курсов.ьТехнология, используемая для реализации 
        этого класса приложений, неизменно «катите самостоятельно», потому что экспертам по приложениям не повезло с готовыми 
        системными программными продуктами.
      </p>
      <p align="justify" class="p_on_project_pages">
        Чтобы более глубоко изучить проблемы обработки кормов, мы теперь подробно опишем конкретный прототип приложения, который был 
        разработан крупным инвестиционным фондом. Эта компания подписывается на несколько коммерческих каналов и имеет текущее 
        производственное приложение, которое отслеживает все каналы на предмет наличия поздних данных. Идея состоит в том, чтобы 
        предупредить трейдеров, если один из коммерческих каналов задерживается, чтобы трейдеры могли знать, что нельзя доверять 
        информации, предоставленной этим фидом. Эта компания недовольна производительностью и гибкостью своего собственного решения 
        и запросила пилотную версию, использующую движок потоковой обработки.
      </p>
      <p align="justify" class="p_on_project_pages">
        Инженеры компании разработали упрощенную версию своего текущего приложения, чтобы изучить различия в производительности между 
        их текущей системой и движком потоковой обработки. Согласно их спецификации, они искали максимальную пропускную способность 
        обработки сообщений на одном компьютере класса ПК для подмножества своего приложения, которое состояло из двух каналов, 
        передающих данные с двух бирж.
      </p>
      <p align="justify" class="p_on_project_pages">
        В частности, существует 4500 ценных бумаг, из которых 500 являются «быстроходными». Тик акции по одной из этих ценных бумаг 
        считается поздним, если он происходит более чем через пять секунд после предыдущего тика по той же ценной бумаге. Остальные 
        4000 символов движутся медленно, и тик запаздывает, если с предыдущего тика прошло 60 секунд.
      </p>
      <p align="justify" class="p_on_project_pages">
        Есть два поставщика каналов, и компания хотела получать предупреждающее сообщение каждый раз, когда один из поставщиков 
        опаздывает. Кроме того, они хотели вести счетчик для каждого провайдера. Когда от любого провайдера было получено 100 поздних 
        тиков, они хотели получить специальное сообщение «это действительно плохо», а затем подавить последующие отдельные отчеты 
        о тиках.
      </p>
      <p align="justify" class="p_on_project_pages">
        Последней проблемой в спецификации компании было то, что они хотели накапливать поздние тики с каждой из двух бирж, 
        скажем, NYSE и NASD, независимо от того, какой поставщик кормов предоставил поздние данные. Если 100 запоздалых сообщений 
        были получены от любого обмена через любого поставщика каналов, они хотели получить два дополнительных специальных сообщения. 
        Таким образом, им нужно четыре счетчика, каждый из которых ведет счет до 100, с получением специального сообщения. 
        Абстрактное представление диаграммы запроса для этой задачи показано на рисунке 3.
      </p>
      <p align="justify" class="p_on_project_pages">
        Хотя это приложение-прототип является лишь подмножеством логики приложения, используемой в реальной производственной системе, 
        оно представляет собой простую для задания задачу, производительность которой можно легко измерить; как таковой, это 
        показательный пример. Теперь перейдем к скорости этого примера приложения на движке потоковой обработки, а также в СУБД.
      </p>
      <div class="section_name">
        4 Обсуждение произвотельности
      </div>
      <p align="justify" class="p_on_project_pages">
        Пример приложения, рассмотренный в предыдущем разделе, был реализован в движке потоковой обработки StreamBase (SPE), 
        который по сути является коммерческой, промышленной версией Aurora. На процессоре Pentium с тактовой частотой 2,8 ГГц, 
        512 Мбайт памяти и одним диском SCSI рабочий процесс, показанный на рисунке 3, может выполняться со скоростью 160 000 
        сообщений в секунду до того, как будет наблюдаться насыщение ЦП. Напротив, инженеры StreamBase могли уговорить только 
        900 сообщений в секунду от реализации того же приложения с использованием популярной коммерческой реляционной СУБД.
      <p align="justify" class="p_on_project_pages">
        В этом разделе мы обсудим основные причины, которые приводят к разнице в наблюдаемых характеристиках на два порядка. 
        Как мы утверждаем ниже, причины связаны с моделью обработки входящих событий, правильными примитивами для потоковой 
        обработки и бесшовной интеграцией обработки СУБД с обработкой приложений. Кроме того, мы также рассматриваем 
        транзакционное поведение, которое часто является еще одним важным фактором.
      </p>
      <div class="subsection_name">
        4.1 «Входящая» и «исходящая» обработка
      </div>
      <p align="justify" class="p_on_project_pages">
        В основе модели СУБД лежит то, что мы называем «исходящей» обработкой, показанной на рисунке 4. В частности, в качестве 
        первого шага вставляются данные в базу данных (шаг 1). После индексации данных и подтверждения транзакции эти данные 
        доступны для последующей обработки запроса (шаг 2), после чего результаты представляются пользователю (шаг 3). 
        Эта модель «процесс после сохранения» лежит в основе всех обычных СУБД, что неудивительно, потому что, в конце концов, 
        основная функция СУБД принимать, а затем никогда не терять данные.
      </p>
      <p align="justify" class="p_on_project_pages">
        В приложениях реального времени операция хранения, которая должна выполняться перед обработкой, значительно увеличивает 
        как задержку в приложении, так и стоимость обработки одного сообщения приложения. Альтернативная модель обработки, 
        позволяющая избежать этого узкого места в хранилище, показана графически на рисунке 5. Здесь входные потоки проталкиваются 
        в систему (шаг 1) и обрабатываются (шаг 2) по мере того, как они «пролетают» в памяти через сеть запросов. 
        Затем результаты отправляются в клиентские приложения для использования (шаг 3). Чтение или запись в хранилище не 
        являются обязательными и во многих случаях могут выполняться асинхронно, если они присутствуют. Тот факт, что хранилище 
        отсутствует или является необязательным, экономит как на стоимости, так и на задержке, что приводит к значительно более 
        высокой производительности. Эта модель, называемая «входящей» обработкой, используется механизмом потоковой обработки, 
        таким как StreamBase.
      </p>
      <p align="justify" class="p_on_project_pages">
        Один из них, конечно, вызывает вопрос: «Может ли СУБД выполнять обработку входящих событий?» Изначально СУБД проектировались 
        как механизмы обработки исходящих сообщений, но спустя много лет в их механизмы были добавлены триггеры. Существует множество 
        ограничений на триггеры (например, количество, разрешенное для таблицы), и нет способа обеспечить безопасность триггеров 
        (то есть гарантировать, что триггеры не переходят в бесконечный цикл). В целом программная поддержка триггеров практически 
        не поддерживается.
      </p>
      <p align="justify" class="p_on_project_pages">
        Например, нет способа увидеть, какие триггеры используются в приложении, и нет способа добавить триггер в таблицу через 
        графический интерфейс пользователя. Более того, виртуальные представления и материализованные представления предоставляются 
        для обычных таблиц, но не для триггеров. Наконец, триггеры часто имеют проблемы с производительностью в существующих 
        механизмах. Когда инженеры StreamBase пытались использовать их для приложения подачи сигналов тревоги, они все равно 
        не могли получать более 900 сообщений в секунду. Таким образом, триггеры добавляются к существующим проектам в последнюю 
        очередь и, таким образом, являются второсортными гражданами в существующих системах.
      </p>
      <p align="justify" class="p_on_project_pages">
        Таким образом, реляционные СУБД это механизмы исходящего трафика, на которые была наложена ограниченная обработка входящих 
        событий. В отличие от этого, механизмы потоковой обработки, такие как Aurora и StreamBase, по сути, являются механизмами 
        обработки входящих событий. С самого начала двигатель на входе выглядит радикально отличным от двигателя исходящего. 
        Например, исходящий механизм использует модель обработки «вытягивания», то есть запрос отправляется, и работа механизма 
        заключается в том, чтобы эффективно извлекать записи из хранилища для удовлетворения запроса. В отличие от этого, движок 
        входящих сообщений использует «проталкивающую» модель обработки, и задача механизма состоит в том, чтобы эффективно 
        проталкивать входящие сообщения через этапы обработки, выполняемые в приложении.
      </p>
      <p align="justify" class="p_on_project_pages">
        Другой способ увидеть различие состоит в том, что исходящий механизм сохраняет данные, а затем выполняет запросы к данным. 
        В отличие от этого, входящий механизм хранит запросы, а затем передает входящие данные (сообщения) через запросы.
      </p>
      <p align="justify" class="p_on_project_pages">
        Хотя кажется возможным сконструировать двигатель, который был бы либо входящим, либо исходящим, такая конструкция явно 
        является исследовательским проектом. Между тем СУБД оптимизированы для обработки исходящих запросов, а механизмы потоковой 
        обработки для обработки входящих. В приложении подачи сигнала тревоги это различие в философии объясняет значительную 
        часть наблюдаемой разницы в производительности.
      </p>
      <div class="subsection_name">
        4.2 Правильные примитивы
      </div>
      <p align="justify" class="p_on_project_pages">
        Системы SQL содержат сложную систему агрегирования, посредством которой пользователь может выполнять статистические 
        вычисления по группировкам записей из таблицы в базе данных. Стандартный пример:
      </p>
      <ul>
        <li><a>Выберите среднюю (зарплату)</a>
        <li><a>От сотрудника</a>
        <li><a>Группировать по отделам</a>
      </ul>
      <p align="justify" class="p_on_project_pages">
        Когда механизм выполнения обрабатывает последнюю запись в таблице, он может выдать совокупный расчет для каждой группы записей. 
        Однако от этой конструкции мало пользы в потоковых приложениях, где потоки продолжаются бесконечно и нет понятия «конец таблицы».
      </p>
      <p align="justify" class="p_on_project_pages">
        Следовательно, механизмы потоковой обработки расширяют SQL (или какой-либо другой язык агрегации) понятием временных окон. В 
        StreamBase окна могут быть определены на основе времени, количества сообщений или точек останова в каком-либо другом атрибуте. 
        В приложении подачи сигнала тревоги крайнее левое поле в каждом потоке является таким агрегатным блоком. Агрегат группирует 
        акции по символам, а затем определяет окна как тики 1 и 2, 2 и 3, 3 и 4 и т. Д. Для каждой акции. Такие «скользящие окна» 
        часто очень полезны в приложениях реального времени.
      </p>
      <p align="justify" class="p_on_project_pages">
        Кроме того, агрегаты StreamBase были созданы для интеллектуальной обработки задержанных, неупорядоченных или отсутствующих 
        сообщений. В приложении подачи сигнала тревоги заказчик принципиально заинтересован в поиске запаздывающих данных. StreamBase 
        позволяет агрегатам в окнах иметь два дополнительных параметра. Первый это параметр тайм-аута, который указывает механизму 
        выполнения StreamBase закрыть окно и выдать значение, даже если условие закрытия окна не было выполнено. Этот параметр 
        эффективно работает с запаздывающими или отсутствующими кортежами. Второй параметр это резерв, который является указанием 
        механизму выполнения держать окно открытым после того, как было выполнено его условие закрытия. Этот параметр устраняет 
        беспорядок в поступлении кортежей. Эти два параметра позволяют пользователю указать, как поступать с отклонениями потока, 
        и могут быть эффективно использованы для повышения отказоустойчивости системы.
      </p>
      <p align="justify" class="p_on_project_pages">
        В приложении подачи сигнала тревоги каждое окно имеет два тика, но имеет тайм-аут 5 или 60 секунд. Это приведет к закрытию 
        окон, если время между поступлениями между последовательными тиками превышает максимум, определенный пользователем. 
        Это очень эффективный способ обнаружения поздних данных; то есть как побочный эффект хорошо настроенной совокупной логики. 
        В примере приложения поле после каждого агрегирования отбрасывает действительные данные и сохраняет только сообщения о 
        тайм-ауте. Остальная часть приложения выполняет необходимый учет этих тайм-аутов.
      </p>
      <p align="justify" class="p_on_project_pages">
        Наличие правильных примитивов на нижних уровнях системы обеспечивает очень высокую производительность. Напротив, реляционный 
        движок не содержит таких встроенных конструкций. Моделирование их эффекта с помощью обычного SQL довольно утомительно и 
        приводит ко второй значительной разнице в производительности.
      </p>
      <p align="justify" class="p_on_project_pages">
        В SQL можно добавить временные окна, но это не имеет смысла для хранимых данных. Следователно, оконные конструкции должны 
        быть интегрированы в какую-то модель входящей обработки.
      </p>
      <div class="subsection_name">
        4.3 Полная интеграция обработки СУБД и логики приложения
      </div>
      <p align="justify" class="p_on_project_pages">
        Все реляционные СУБД были разработаны с учетом архитектуры клиент-сервер. В этой модели есть много клиентских приложений, 
        которые могут быть написаны произвольными людьми и поэтому обычно не пользуются доверием. Следовательно, из соображений 
        безопасности и надежности эти клиентские приложения запускаются в адресном пространстве, отдельном от СУБД. Цена этого выбора 
        заключается в том, что приложение работает в одном адресном пространстве, а обработка СУБД в другом, и для перехода из одного 
        адресного пространства в другое требуется переключение процесса.
      </p>
      <p align="justify" class="p_on_project_pages">
        Напротив, приложение подачи сигнала тревоги является примером встроенной системы. Он написан одним человеком или группой, 
        которым доверяют «делать правильные вещи». Все приложение состоит из (1) обработки СУБД, например блоков агрегирования и 
        фильтрации, (2) управляющей логики для направления сообщений на правильный следующий этап обработки и (3) логики приложения. 
        В StreamBase эти три вида функций можно свободно чередовать. Логика приложения поддерживается с помощью определяемых 
        пользователем полей, поля Count100 в нашем примере приложения для обработки финансовых потоков. Фактический код, 
        показанный на рисунке 6, состоит из четырех строк C ++, который считает до 100 и устанавливает флаг, обеспечивающий отправку правильных сообщений. Логика управления поддерживается за счет разрешения нескольких предикатов в блоке фильтра и, следовательно, нескольких выходных дуг. Таким образом, блок фильтра выполняет логику «если-тоеще» в дополнение к фильтрации потоков.
      </p>
      <p align="justify" class="p_on_project_pages">
        По сути, приложение подачи сигнала тревоги представляет собой сочетание обработки в стиле СУБД, условных выражений и 
        определяемых пользователем функций на обычном языке программирования. Эта комбинация выполняется StreamBase в едином 
        адресном пространстве без каких-либо переключателей процесса. Такая бесшовная интеграция логики СУБД с традиционными 
        средствами программирования была предложена много лет назад в Rigel и Pascal-R, но никогда не была реализована в 
        коммерческих реляционных системах. Вместо этого основные поставщики внедрили хранимые процедуры, которые представляют 
        собой гораздо более ограниченные системы программирования. Совсем недавно появление объектно-реляционных механизмов 
        предоставило блейды или расширители, которые более мощные, чем хранимые процедуры, но все же не обеспечивают гибкую 
        логику управления.
      </p>
      <p align="justify" class="p_on_project_pages">
        Встроенные системы не нуждаются в защите, обеспечиваемой СУБД клиент-сервер, а двухуровневая архитектура просто создает 
        накладные расходы. Это третий источник разницы в производительности, наблюдаемой в нашем примере приложения.
      </p>
      <p align="justify" class="p_on_project_pages">
        Другая проблема интеграции, не проиллюстрированная примером сигнала тревоги подачи, это хранение информации о состоянии 
        в потоковых приложениях. Большинству приложений потоковой обработки требуется сохранение некоторого состояния, от 
        небольшого количества мегабайт до небольшого количества гигабайт. Такая информация о состоянии может включать (1) 
        справочные данные (т. Е. Какие акции представляют интерес), (2) таблицы перевода (в случае, если в фидах используются 
        разные символы для одной и той же акции) и (3) исторические данные (например, «сколько поздние клещи в течение 
        последнего года наблюдались ежедневно? »). Таким образом, табличное хранение данных является требованием для 
        большинства приложений потоковой обработки.
      </p>
      <p align="justify" class="p_on_project_pages">
        StreamBase встраивает BerkeleyDB для хранения состояний. Однако разница в производительности между вызовом BerkeleyDB 
        в адресном пространстве StreamBase и его вызовом в режиме клиент-сервер в другом адресном пространстве составляет 
        примерно один порядок. Это еще одна причина избегать переключения процессов путем смешивания СУБД и обработки 
        приложений в одном адресном пространстве.
      </p>
      <p align="justify" class="p_on_project_pages">
        Хотя можно было бы предположить, что СУБД улучшают свои модели программирования для решения этой проблемы 
        производительности, существуют очень веские причины, по которым СУБД клиент-сервер были спроектированы именно так. 
        Большинство приложений для обработки бизнес-данных нуждаются в защите, предоставляемой этой моделью. Хранимые процедуры 
        и объектно-реляционные блейды были попыткой перенести часть клиентской логики на сервер для повышения производительности. 
        Чтобы двигаться дальше, СУБД должна будет реализовать как встроенную, так и невстроенную модель с разными системами времени 
        выполнения. Опять же, это будет означать отказ от «одного размера для всех».
      </p>
      <p align="justify" class="p_on_project_pages">
        Напротив, системы обработки кормов всегда являются встроенными приложениями. Следовательно, приложение и СУБД пишутся 
        одними и теми же людьми и управляются из внешних каналов, а не из транзакций, введенных человеком. Таким образом, нет 
        причин защищать СУБД от приложения, и вполне допустимо запускать обе в одном адресном пространстве. Во встроенной модели 
        обработки разумно свободно смешивать логику приложения, логику управления и логику СУБД, что и делает StreamBase.
      </p>
      <div class="subsection_name">
        4.4 Высокая доступность
      </div>
      <p align="justify" class="p_on_project_pages">
        Для многих потоковых приложений требуется высокая доступность и постоянная работа 24x7. Стандартные механизмы ведения журналов 
        СУБД и восстановления после сбоев плохо подходят для мира потоковой передачи, поскольку они создают несколько ключевых проблем.
      </p>
      <p align="justify" class="p_on_project_pages">
        Во-первых, восстановление на основе журнала может занять от большого количества секунд до небольшого количества минут. В этот 
        период приложение будет «неактивно». Такое поведение явно нежелательно во многих доменах потоковой передачи в реальном времени 
        (например, в финансовых услугах). Во-вторых, в случае сбоя необходимо приложить некоторые усилия для буферизации входящих 
        потоков данных, иначе эти данные будут безвозвратно потеряны в процессе восстановления. В-третьих, восстановление СУБД будет 
        иметь дело только с табличным состоянием и, таким образом, будет игнорировать состояния операторов. Например, в приложении 
        подачи сигнала тревоги счетчики не хранятся в таблицах; поэтому их состояние будет потеряно в результате аварии. Одно из 
        простых исправлений принудительное занесение всех состояний операторов в таблицы для использования восстановления в стиле 
        СУБД; однако это решение значительно замедлит работу приложения.
      </p>
      <p align="justify" class="p_on_project_pages">
        Очевидной альтернативой для достижения высокой доступности является использование методов, основанных на тандемных парах 
        процессов. Основная идея состоит в том, что в случае сбоя приложение выполняет переключение на резервную машину, которая 
        обычно работает как «горячий резерв», и продолжает работу с небольшой задержкой. Такой подход устраняет накладные расходы 
        на ведение журнала. Например, StreamBase отключает ведение журнала в BerkeleyDB.
      </p>
      <p align="justify" class="p_on_project_pages">
        В отличие от традиционных приложений обработки данных, которые требуют точного восстановления для корректности, многие 
        приложения потоковой обработки могут терпеть и извлекать выгоду из более слабых представлений о восстановлении. Другими 
        словами, аварийное переключение не всегда должно быть «идеальным».
      </p>
      <p align="justify" class="p_on_project_pages">
        Рассмотрите возможность мониторинга приложений, которые работают с потоками данных, значения которых периодически обновляются. 
        Такие приложения часто могут терпеть потери кортежей при сбое, если такие прерывания короткие. Точно так же, если кто-то 
        потеряет пару тиков в приложении подачи сигнала тревоги во время переключения при отказе, правильность, вероятно, все равно 
        сохранится. Напротив, приложения, которые запускают предупреждения при возникновении определенных комбинаций событий, не 
        требуют потери кортежей, но могут допускать временное дублирование. Например, приложение для наблюдения за пациентом может 
        допускать повторяющиеся кортежи (“ частота пульса 79 ”), но не потерянные кортежи (“ частота пульса изменилась на ноль ”). 
        Конечно, всегда найдется класс приложений, требующих надежных и точных гарантий восстановления. Финансовое приложение, которое 
        выполняет управление портфелем на основе отдельных операций с акциями, попадает в эту категорию.
      </p>
      <p align="justify" class="p_on_project_pages">
        В результате появляется возможность разработать упрощенные схемы переключения при отказе с низкими накладными расходами, 
        когда достаточно более слабых понятий корректности. Недавно был изучен набор подробных вариантов того, как достичь высокой 
        доступности в мире потоковой передачи.
      </p>
      <div class="subsection_name">
        4.5 Синхронизация
      </div>
      <p align="justify" class="p_on_project_pages">
        Многие потоковые приложения полагаются на общие данные и вычисления. Общие данные обычно содержатся в таблице, которую один 
        запрос обновляет, а другой читает. Например, приложение Linear Road требует, чтобы данные о местоположении транспортного 
        средства использовались для обновления статистики использования шоссе, которая, в свою очередь, считывается для определения 
        платы за проезд для каждого сегмента шоссе. Таким образом, существует основная потребность в обеспечении изоляции между 
        сообщениями.
      </p>
      <p align="justify" class="p_on_project_pages">
        Традиционные СУБД используют транзакции ACID для обеспечения изоляции (среди прочего) между параллельными транзакциями, 
        отправленными несколькими пользователями. В потоковых системах, которые не являются многопользовательскими, такая изоляция 
        может быть эффективно достигнута с помощью простых критических секций, которые могут быть реализованы с помощью облегченных 
        семафоров. Поскольку полноценные транзакции не требуются, больше нет необходимости использовать тяжелые механизмы на основе 
        блокировок.
      </p>
      <p align="justify" class="p_on_project_pages">
        Таким образом, свойства ACID не требуются в большинстве приложений потоковой обработки, и более простые, специализированные 
        конструкции производительности могут быть использованы с пользой.
      </p>
      <div class="section_name">
        5. Один размер подходит всем?
      </div>
      <p align="justify" class="p_on_project_pages">
        В предыдущем разделе был указан набор архитектурных проблем, которые приводят к значительным различиям в производительности 
        между специализированными механизмами потоковой обработки и традиционными СУБД. Такой выбор конструкции приводит к большой 
        разнице между внутренними компонентами двух двигателей. Фактически, код времени выполнения в StreamBase совсем не похож на 
        традиционный исполняемый код СУБД. Конечный результат значительно лучшая производительность в классе приложений реального 
        времени. Эти соображения приведут к отдельной строке кода для потоковой обработки, конечно, при условии, что рынок достаточно 
        велик, чтобы облегчить этот сценарий.
      </p>
      <p align="justify" class="p_on_project_pages">
        В оставшейся части раздела мы опишем несколько других рынков, на которых специализированные механизмы баз данных могут 
        оказаться жизнеспособными.
      </p>
      <div class="subsection_name">
        5.1 Хранилища данных
      </div>
      <p align="justify" class="p_on_project_pages">
        Архитектурные различия между системами OLTP и хранилищами баз данных, обсуждаемыми в разделе 2, являются лишь верхушкой 
        айсберга, и со временем возникнут дополнительные различия. Теперь мы сосредоточимся, вероятно, на самом большом архитектурном 
        различии, которое заключается в хранении данных по столбцам, а не по строкам.
      </p>
      <p align="justify" class="p_on_project_pages">
        Все основные поставщики СУБД реализуют системы хранения, ориентированные на записи, в которых атрибуты записи размещаются 
        в хранилище непрерывно. Используя эту архитектуру «строкового хранилища», одна запись на диск это все, что требуется для 
        передачи всех атрибутов одной записи на диск. Следовательно, такая система «оптимизирована для записи», поскольку легко 
        достижима высокая производительность при записи записей. Легко видеть, что системы, оптимизированные для записи, особенно 
        эффективны для приложений в стиле OLTP, что является основной причиной, по которой большинство коммерческих СУБД используют 
        эту архитектуру.
      </p>
      <p align="justify" class="p_on_project_pages">
        В отличие от этого, складские системы необходимо «оптимизировать для повторной оптимизации», поскольку большая часть рабочей 
        нагрузки состоит из специальных запросов, которые затрагивают большие объемы исторических данных. В таких системах модель 
        «хранилище столбцов», в которой значения для всех строк одного атрибута хранятся непрерывно, значительно более эффективна 
        (как показали Sybase IQ, Addamark и KDB).
      </p>
      <p align="justify" class="p_on_project_pages">
        В архитектуре с колоночным хранилищем СУБД нужно только читать атрибуты, необходимые для обработки данного запроса, и она 
        может избежать занесения в память любых других нерелевантных атрибутов. Учитывая, что записи с сотнями атрибутов (со многими 
        нулевыми значениями) становятся все более распространенными, этот подход приводит к значительному преимуществу в 
        производительности для рабочих нагрузок хранилища, где типичные запросы включают агрегаты, которые вычисляются на 
        небольшом количестве атрибутов над большими наборами данных. Первый автор этой статьи участвует в исследовательском 
        проекте по изучению преимуществ производительности системы с колоночным хранилищем.
      </p>
      <div class="subsection_name">
        5.2 Сенсорные сети
      </div>
      <p align="justify" class="p_on_project_pages">
        Нецелесообразно запускать традиционную СУБД в узлах обработки, которые управляют датчиками в сенсорной сети. Эти новые 
        платформы сетей устройств в настоящее время исследуются для таких приложений, как экологический и медицинский мониторинг, 
        промышленная автоматизация, автономные роботы и умные дома.
      </p>
      <p align="justify" class="p_on_project_pages">
        Чтобы полностью реализовать потенциал этих систем, компоненты разработаны так, чтобы быть беспроводными в отношении как 
        связи, так и энергии. В этой среде пропускная способность и мощность становятся ключевыми ресурсами, которые необходимо 
        сохранить. Кроме того, связь, в отличие от обработки или доступа к хранению, является основным потребителем энергии. 
        Таким образом, стандартные тактики оптимизации СУБД неприменимы, и их необходимо критически переосмыслить. Более того, 
        транзакционные возможности в этой области кажутся неуместными.
      </p>
      <p align="justify" class="p_on_project_pages">
        В общем, существует потребность в разработке гибких, легких абстракций базы данных (таких как TinyDB), которые оптимизированы 
        для перемещения данных, а не для хранения данных.
      </p>
      <div class="subsection_name">
        5.3 Текстовый поиск
      </div>
      <p align="justify" class="p_on_project_pages">
        Ни одна из современных систем текстового поиска не использует технологию СУБД для хранения, даже если они имеют дело с 
        огромными,постоянно увеличивающимися наборами данных. Например, Google построил свою собственную систему хранения 
        (названную GFS), которая превосходит традиционную технологию СУБД (а также технологию файловой системы) по некоторым 
        причинам, обсуждаемым в разделе 4.
      </p>
      <p align="justify" class="p_on_project_pages">
        Типичная рабочая нагрузка поисковой системы состоит из комбинации входящих потоковых данных (поступающих от веб-сканеров), 
        которые необходимо очистить и включить в существующий поисковый индекс, и специальных операций поиска по существующему 
        индексу. В частности, операции записи в основном являются последовательными операциями только добавления и чтения. 
        Одновременные записи (т. Е. Добавления) в один и тот же файл необходимы для хорошей производительности. Наконец, 
        большое количество складских машин, состоящих из товарных частей, гарантирует, что выход из строя является скорее нормой, 
        чем исключением. Следовательно, высокая доступность является ключевым аспектом проектирования и может быть достигнута 
        только за счет быстрого восстановления и репликации.
      </p>
      <p align="justify" class="p_on_project_pages">
        Очевидно, что эти характеристики приложений сильно отличаются от характеристик обычных бизнес-приложений. В результате, 
        даже несмотря на то, что некоторые СУБД имеют встроенные возможности текстового поиска, они не соответствуют требованиям 
        к производительности и доступности этого домена: они просто слишком тяжелые и негибкие.
      </p>
      <div class="subsection_name">
        5.4 Научные базы данных
      </div>
      <p align="justify" class="p_on_project_pages">
        Огромные объемы данных постоянно собираются из реального мира датчиками различных типов, прикрепленными к таким устройствам, 
        как спутники и микроскопы, или генерируются искусственно с помощью научных и инженерных симуляций с высоким разрешением.
      </p>
      <p align="justify" class="p_on_project_pages">
        Анализ таких наборов данных является ключом к лучшему пониманию физических явлений и становится все более обычным явлением 
        во многих областях научных исследований. Эффективный анализ и запросы к этим обширным базам данных требуют высокоэффективных 
        многомерных структур индексации и методов агрегирования для конкретных приложений. Кроме того, потребность в эффективных 
        методах архивирования, промежуточного хранения, происхождения и распространения ошибок может создать потребность в еще 
        одном специализированном механизме в этой важной области.
      </p>
      <div class="subsection_name">
        5.5 Базы данных XML
      </div>
      <p align="justify" class="p_on_project_pages">
        Полуструктурированные данные есть везде. К сожалению, такие данные не сразу попадают в реляционную модель. В настоящее 
        время ведутся жаркие споры о том, как лучше всего хранить XML-данные и манипулировать ими. Хотя некоторые считают, что 
        реляционные СУБД (с соответствующими расширениями) это правильный выбор, другие утверждают, что для хранения и обработки 
        этого формата данных необходим специализированный механизм.
      </p>
      <div class="section_name">
        6. Комментарий по факторингу
      </div>
      <p align="justify" class="p_on_project_pages">
        Большинству потоковых приложений требуются три основных сервиса:
      </p>
      <ul>
        <li><a>• Транспорт сообщений: во многих потоковых приложениях существует потребность в эффективной и надежной передаче 
          данных между несколькими распределенными машинами. У этого есть три причины. Во-первых, источники и места назначения 
          данных обычно географически рассредоточены. Во-вторых, требования к высокой производительности и доступности диктуют 
          использование нескольких взаимодействующих серверных машин. В-третьих, практически все большие корпоративные системы 
          состоят из сложной сети бизнесприложений, работающих на большом количестве машин, в которые встроен SPE. Таким образом, 
          входящие и выходные сообщения для SPE должны быть правильно маршрутизированы из и в соответствующие внешние приложения.</a>
        <li><a>• Хранение состояния: как обсуждалось в разделе 4.3, во всех приложениях, кроме самых упрощенных, существует 
          потребность в хранении состояния, обычно в форме доступных только для чтения справочных и исторических таблиц, а 
          также таблиц преобразования чтения-записи (например, хештаблиц).</a>
        <li><a>• Выполнение логики приложения. Многие потоковые приложения требуют, чтобы обработка сообщений, зависящая от 
          предметной области, перемежалась с активностью запросов. В общем, невозможно и непрактично представить такую логику 
          приложения, используя только встроенные примитивы запросов (например, подумайте о устаревшем коде).</a>
      </ul>
      <p align="justify" class="p_on_project_pages">
        Традиционный дизайн приложения потоковой обработки распределяет всю логику приложения по трем разным системам: (1) 
        система обмена сообщениями (например, MQSeries, WebMethods или Tibco) для надежного соединения компонентных систем, 
        обычно с использованием парадигмы публикации / подписки; (2) СУБД (например, DB2 или Oracle) для сохранения информации 
        о состоянии; и (3) сервер приложений (например, WebSphere или WebLogic) для предоставления сервисов приложений для 
        набора программ с пользовательским кодом. Такая трехуровневая конфигурация проиллюстрирована на рисунке 7.
      </p>
      <p align="justify" class="p_on_project_pages">
        К сожалению, такая конструкция, которая распределяет требуемую функциональность между тремя тяжелыми частями системного 
        программного обеспечения, не будет работать хорошо. Например, каждое сообщение, которое требует поиска состояния и служб 
        приложений, повлечет за собой несколько переключений процессов между этими различными службами.
      </p>
      <p align="justify" class="p_on_project_pages">
        Чтобы проиллюстрировать эти накладные расходы на каждое сообщение, мы отслеживаем шаги, предпринятые при обработке 
        сообщения. Входящее сообщение сначала принимается шиной, а затем переадресовывается пользовательскому коду приложения 
        (шаг 1), которое очищает, а затем обрабатывает сообщение. Если сообщение необходимо сопоставить с историческими данными 
        или требуется доступ к постоянным данным, то запрос отправляется на сервер БД (шаги 2-3), который обращается к СУБД. 
        Ответ следует обратному пути к коду приложения (шаги 4–5). Наконец, результат обработанного сообщения пересылается в 
        графический интерфейс клиентской задачи (шаг 6). Всего существует шесть «переходов границы» для обработки одного 
        сообщения. Помимо очевидных переключений контекста, сообщения также необходимо на лету преобразовывать с помощью 
        соответствующих адаптеров в собственные форматы систем и обратно каждый раз, когда они принимаются и передаются на 
        шину сообщений. В результате получается очень низкое соотношение полезной работы к накладным расходам. Даже при 
        некотором пакетировании сообщений накладные расходы будут высокими и ограничивают достижимую производительность.
      </p>
      <p align="justify" class="p_on_project_pages">
        Чтобы избежать такого снижения производительности, механизм потоковой обработки должен предоставлять все три службы 
        в едином системном программном обеспечении, которое выполняется как один многопоточный процесс на каждой машине, на 
        которой он работает. Следовательно, SPE должен иметь элементы СУБД, сервера приложений и системы обмена сообщениями.
      </p>
      <p align="justify" class="p_on_project_pages">
        Фактически, SPE должен предоставлять специализированные возможности всех трех типов программного обеспечения «под 
        одной крышей».
      </p>
      <p align="justify" class="p_on_project_pages">
        Это наблюдение поднимает вопрос о том, является ли текущее разделение системного программного обеспечения на 
        компоненты (например, сервер приложений, СУБД, система извлеченияпреобразования-загрузки, шина сообщений, 
        файловая система, веб-сервер и т. Д.) Оптимальным. В конце концов, это конкретное разложение возникло 
        отчасти как исторический артефакт, а отчасти из-за рыночной случайности. Похоже, что и другой факторинг 
        системных сервисов кажется столь же правдоподобным, и неудивительно, что в будущем будет происходить существенная 
        эволюция определения компонентов и их факторизации.
      </p>
      <div class="section_name">
        7. Заключительные замечания
      </div>
      <p align="justify" class="p_on_project_pages">
        Подводя итог, можно сказать, что в будущем может появиться значительное количество движков баз данных для 
        конкретных доменов с различными возможностями. Нам напоминают проклятие «Живите в интересные времена». Мы 
        считаем, что рынок СУБД вступает в период очень интересных времен. Существует множество существующих и 
        новых приложений, которые могут извлечь выгоду из принципов и методов управления и обработки данных. В то 
        же время эти приложения очень сильно отличаются от обработки бизнес-данных и друг от друга кажется, нет 
        очевидного способа поддержать их с помощью одной строки кода. Тема «один размер для всех» вряд ли сможет 
        успешно развиваться в этих условиях.
      </p>
    </div>
  </div>
</body>