<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Knowlege base - Kirill Dikalin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../knowlege_base/kb_css.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/monokai-sublime.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <link rel="icon" href="../images/favicon.ico" type="image/x-icon">
</head>

<body>
  <ul class="breadcrumb">
    <a class="bread_crumb" href="../index.html">Kirill Dikalin</a> / База знаний
  </ul>

  <h1 style="padding-top: 1em;"> Оглавление </h1>
  <ul>
    <li><a href="#Python" class="intext">Python</a></li>
    <ul>
      <li><a href="#General questions" class="intext">Общие вопросы по языку</a></li>
      <li><a href="#OOP" class="intext">ООП</a></li>
        <ul>
          <li><a href="#SOLID" class="intext">SOLID</a>
          <li><a href="#classes" class="intext">Что такое классы</a>
          <li><a href="#magic-methods" class="intext">Что такое магические методы</a>
          <li><a href="#mixin" class="intext">Что такое миксин</a>
        </ul>
      <li><a href="#Types-and-data-structures-in-python" class="intext">Типы и структуры данных в python</a></li>
        <ul>
          <li><a href="#Types-and-data-structures" class="intext">Какие типы и структуры данных бывают в python?</a></li>
          <li><a href="#mutable-and-immutable-data-types" class="intext">Что такое мутабельные и иммутабельные типы данных?</a></li>
          <li><a href="#dictionary-key" class="intext">Что может быть в качестве ключа словаря?</a></li>
          <li><a href="#python-hash" class="intext">Что такое хеш-функция?</a></li>
          <li><a href="#dictionary-in-python" class="intext">В чём особенность словаря в python?</a></li>
          <li><a href="#lists-tuples-and-sets" class="intext">Списки, кортежи и множества в чём их отличие?</a></li>
        </ul>
      <li><a href="#GIL" class="intext">GIL</a></li>
        <ul>
          <li><a href="#what-is-GIL" class="intext">Что такое GIL?</a></li>
          <li><a href="#multithreaded-and-multiprocessing-programs-in-python" class="intext">Многопоточные и многопроцессорные программы в python</a></li>
          <li><a href="#difference-between-threads-and-processes" class="intext">Разница между потоками и процессами</a></li>
          <li><a href="#what-are-race-conditions-and-thread-safety" class="intext">Что такое условия гонки и потокобезопасность?</a></li>
          <li><a href="#algorithm-for-scheduling-access-of-streams-to-shared-data" class="intext">Алгоритм планирования доступа потоков к общим данным</a></li>
        </ul>
      <li><a href="#GC" class="intext">GC</a></li>
        <ul>
          <li><a href="#memory-management-in-python" class="intext">Как в питоне обстоят дела с памятью (управлением памятью)</a></li>
          <li><a href="#how-much-does-it-cost-to-validate-an-element-in-notation" class="intext">Сколько стоит проверка элемента в нотации?</a></li>
          <li><a href="#two-objects" class="intext">Если есть два объекта и они указывают друг на друга</a></li>
        </ul>
      <li><a href="#Iterators-decorators-and-generators" class="intext">Итераторы, декораторы и генераторы</a></li>
        <ul>
          <li><a href="#what-is-iterator" class="intext">Что такое итератор?</a></li>
          <li><a href="#what-is-generator" class="intext">Что такое генератор?</a></li>
          <li><a href="#what-is-decorator" class="intext">Что такое декоратор?</a></li>
          <li><a href="#standard-library-decorators" class="intext">Какие декораторы стандартной библиотеки вы знаете?</a></li>
          <li><a href="#list-comprehension" class="intext">Что такое list comprehension, какой синтаксис создания генераторов?</a></li>
          <li><a href="#s-range-an-iterator" class="intext">Является ли range итератором?</a></li>
        </ul> 
      <li><a href="#Algorithms" class="intext">Алгоритмы</a></li>
    </ul>
    <li><a href="#SQL" class="intext">SQL</a></li>
    <ul>
      <li><a href="#What-is-a-DBMS" class="intext">Что такое СУБД?</a></li>
      <li><a href="#types-of-DBMS" class="intext">Какие типы СУБД в соответствии с моделями данных существуют?</a></li>
      <li><a href="#primary-key" class="intext">Что такое первичный ключ?</a></li>
      <li><a href="#external-key" class="intext">Что такое внешний ключ?</a></li>
      <li><a href="#limitations-in-SQL" class="intext">Ограничения в SQL</a></li>
      <li><a href="#self-join" class="intext">Что такое Self JOIN?</a></li>
      <li><a href="#wildcards" class="intext">Подстановочные знаки</a></li>
      <li><a href="#aliases" class="intext">Что делают псевдонимы Aliases?</a></li>
      <li><a href="#difference-between-DELETE-and-TRUNCATE" class="intext">Разница между командами DELETE и TRUNCATE</a></li>
      <li><a href="#difference-between-WHERE-and-HAVING" class="intext">vРазница между WHERE и HAVING</a></li>
      <li><a href="#basic-sql-commands" class="intext">Основные команды SQL</a></li>
      <li><a href="#math-functions" class="intext">Математические функции в SQL</a></li>
      <li><a href="#window-functions" class="intext">Оконные функции в SQL</a></li>
      <li><a href="#differences-between-relational-and-non-relational-databases" class="intext">Отличия реляционных и нереляционных баз данных</a></li>
    </ul>
    <li><a href="#Big-Data" class="intext">Big Data</a></li>
    <ul>
      <li><a href="#dwh" class="intext">Что такое DWH</a></li>
      <li><a href="#data-lake" class="intext">Data Lake</a></li>
      <li><a href="#data-marts" class="intext">Витрины данных</a></li>
      <li><a href="#ETL" class="intext">ETL и ETL-запросы</a></li>
      <li><a href="#ETL-process" class="intext">Разработка ETL-процесса</a></li>
      <li><a href="#Elements-of-the-ETL-process" class="intext">Элементы ETL-процесса</a></li>
      <li><a href="#hadoop" class="intext">Что такое Hadoop?</a></li>
      <li><a href="#data-vault" class="intext">Data Vault</a></li>
      <li><a href="#Apache-Kafka" class="intext">Apache Kafka</a></li>
      <li><a href="#Greenplum" class="intext">Greenplum</a></li>
      <li><a href="#distributed-file-system-HDFS" class="intext">Распределенная файловая система HDFS</a></li>
        <ul>
          <li><a href="#HDFS-architecture" class="intext">Архитектура HDFS</a></li>
          <li><a href="#Shell-commands" class="intext">Shell-команды</a></li>
          <li><a href="#Java_API1" class="intext">Java API</a></li>
        </ul>
      <li><a href="#MapReduce" class="intext">MapReduce</a></li>
        <ul>
          <li><a href="#MapReduce-paradigm" class="intext">Парадигма MapReduce</a></li>
          <li><a href="#MapReduce-framework" class="intext">Фреймворк MapReduce</a></li>
          <li><a href="#Java_API2" class="intext">Java API</a></li>
          <li><a href="#Hadoop-Streaming" class="intext">Hadoop Streaming</a></li>
        </ul>
      <li><a href="#Solving-problems-with-MapReduce" class="intext">Решение задач с помощью MapReduce</a></li>
        <ul>
          <li><a href="#Algorithms-on-MapReduce" class="intext">Алгоритмы на MapReduce</a></li>
          <li><a href="#Relational-functions" class="intext">Реляционные функции</a></li>
          <li><a href="#TF-IDF-calculation" class="intext">Расчет TF-IDF</a></li>
        </ul>
      <li><a href="#Graph-Algorithms-in-MapReduce" class="intext">Алгоритмы на графах в MapReduce</a></li>
        <ul>
          <li><a href="#Graphs-in-MapReduce" class="intext">Графы в MapReduce</a></li>
          <li><a href="#Finding-the-shortest-path-in-a-graph" class="intext">Поиск кратчайшего пути в графе</a></li>
          <li><a href="#PageRank" class="intext">PageRank</a></li>
          <li><a href="#Problems-of-MR-algorithms-on-graphs" class="intext">Проблемы MR-алгоритмов на графах</a></li>
        </ul>
      <li><a href="#Pig-and-Hive" class="intext">Pig и Hive</a></li>
        <ul>
          <li><a href="#Pig" class="intext">Pig</a></li>
          <li><a href="#Basic-operators-of-PigLatin" class="intext">Основные операторы PigLatin</a></li>
          <li><a href="#Hive" class="intext">Hive</a></li>
          <li><a href="#Pig-vs-Hive" class="intext">Pig vs Hive</a></li>
        </ul>
      <li><a href="#HBase-and-Cassandra" class="intext">NoSQL базы данных: HBase и Cassandra</a></li>
        <ul>
          <li><a href="#Data-storage-methods" class="intext">Способы хранения данных</a></li>
          <li><a href="#NoSQL" class="intext">NoSQL</a></li>
          <li><a href="#Introduction-to-HBase" class="intext">Введение в HBase</a></li>
          <li><a href="#HBase-architecture" class="intext">Архитектура HBase</a></li>
          <li><a href="#Cassandra" class="intext">Cassandra</a></li>
        </ul>
      <li><a href="#Spark" class="intext">Spark</a></li>
        <ul>
          <li><a href="#Basic-concepts-of-Spark" class="intext">Основные понятия Spark</a></li>
          <li><a href="#Spark-Operators" class="intext">Операторы Spark</a></li>
          <li><a href="#Spark-framework" class="intext">Фреймворк Spark</a></li>
        </ul>
      <li><a href="#YARN" class="intext">YARN. MapReduce 2.0</a></li>
        <ul>
          <li><a href="#What-is-YARN" class="intext">Что такое YARN?</a></li>
          <li><a href="#YARN-components" class="intext">Компоненты YARN</a></li>
          <li><a href="#MapReduce-2.0" class="intext">MapReduce 2.0</a></li>
        </ul>
    </ul>

      <h1 id="Python">Python</h1>
      <h2 id="General questions">Общие вопросы по языку</h2>

      <h3>Разница 2 и 3 версии python</h3>
      <br />
      В Python 2 print был оператором: <code class="python inline">print "Hello, world"</code><br />
      В Python 3 print - функция: <code class="python inline">print ("Hello, world")</code><br />
      <br />
      В Python 2 были две функции: <code class="python inline">range</code> - возвращает список; <code class="python inline">xrange</code> - возвращает итератор<br />
      В Python 3 есть только функция <code class="python inline">range</code>, и она возвращает итератор<br />
      <br />
      В Python 2 при делении целых чисел возвращает целоче число<br />
      В Python 3 при делении целых чисел возвращает вещественное число<br />
      <br />

      <h3>Магические методы</h3>      

      Так как в Питоне 3 различий между строкой и юникодом больше нет,  <code class="python inline">__unicode__</code>  исчез, а появился  <code class="python inline">__bytes__</code>  (который ведёт себя так же как  <code class="python inline">__str__</code>  и  <code class="python inline">__unicode__</code>  в 2.7) для новых встроенных функций построения байтовых массивов.<br /><br />
      Так как деление в Питоне 3 теперь по-умолчанию «правильное деление»,  <code class="python inline">__div__</code>  больше нет.<br /><br />
       <code class="python inline">__coerce__</code>  больше нет, из-за избыточности и странного поведения.<br /><br />
       <code class="python inline">__cmp__</code>  больше нет, из-за избыточности.<br /><br />
       <code class="python inline">__nonzero__</code>  было переименовано в  <code class="python inline">__bool__</code> .<br /><br />
       <code class="python inline">next</code>  у итераторов был переименован в  <code class="python inline">__next__</code> .<br /><br />

      <h2 id="OOP">ООП</h2>

      <h3 id="SOLID">SOLID</h3>

      S - Принцип единственной ответственности (single responsibility principle)<br />
      Для каждого класса должно быть определено единственное назначение. Не должно возникать God object, который занимается всем в программе.<br /><br />

      O - Принцип открытости/закрытости (open–closed principle)<br />
      «программные сущности … должны быть открыты для расширения, но закрыты для модификации». Мы должны иметь возможность добавлять функциональность.<br /><br />

      L - Принцип подстановки Барбары Лисков (Liskov substitution principle)<br />
      «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы». У объекта есть тип, но сами классы выстраиваются в иерархию классов. Подтип типа всю старую функциональность должен выполнять.<br /><br /> 

      I - Принцип разделения интерфейса (interface segregation principle)<br />
      «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения». Интерфейс - способ провзаимодействовать с какой-то программной действующей функцией.<br /><br /> 

      D - Принцип инверсии зависимостей (dependency inversion principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное».<br /><br />
      
      <h3 id="classes">Что такое классы</h3>
      
      Класс — тип, описывающий устройство объектов. Объект — это экземпляр класса.
      
      <pre><code class="language-python">class C: 
  pass 
имя_объекта = имя_класса()</code></pre>
      
      У класса может не быть тела. 

      Простейший пример класса:
      <pre><code class="python">class Rectangle:
  default_color = "green" # статический атрибут 
  def __init__(self, width, height): # конструктор класса
    self.width = width # динамический атрибут
    self.height = height # динамический атрибут</code></pre>
      
      В python нет возможности сделать несколько конструкторов. 

      <h3 id="magic-methods">Что такое магические методы</h3>

      Если какой-то идентификатор начинается с двух подчёркиваний, дальше пишется что-либо, потом снова два подчёркивания, то это спец метод.<br />
      <h4>Какие магические методы и для чего используются?</h4> 

      <pre><code class="python">class FileObject:
  def __init__(self, filepath='~', filename='sample.txt'): # Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.
    self.file = open(join(filepath, filename), 'r+') # Открыть файл filename в filepath в режиме чтения и записи
  def __del__(self):
    self.file.close()
    del self.file</code></pre>
    Метод, который будет вызван при инициализации объекта.<br />
    Это первый метод, который будет вызван при инициализации объекта. Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в <code class="python inline">__init__</code> . <code class="python inline">__new__</code> используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка.<br />
    
    <pre><code class="python">__new__(cls, [...])</code></pre>

    Инициализатор класса. Самый базовый магический метод, <code class="python inline">__init__</code> . С его помощью мы можем инициализировать объект.
    
    <pre><code class="python">__init__(self, [...])</code></pre>
    Деструктор объекта
    <pre><code class="python">__del__</code></pre>

    Самый базовый из методов сравнения <code class="python inline">__cmp__(self, other)</code> . Он, в действительности, определяет поведение для 
    всех операторов сравнения (>, ==, !=, итд.), но не всегда так, как вам это нужно (например, если эквивалентность 
    двух экземпляров определяется по одному критерию, а то что один больше другого по какому-нибудь другому). 
    <code class="python inline">__cmp__</code> должен вернуть отрицательное число, если <code class="python inline">self < other</code> , ноль, если <code class="python inline">self == other</code> , и положительное число 
    в случае <code class="python inline">self > other</code> . Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех 
    в <code class="python inline">__cmp__</code> . Но <code class="python inline">__cmp__</code> может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые 
    сравнения оперируют одним критерием.
    <ul>
    <li><a><code class="python inline">__eq__(self, other)</code> Определяет поведение оператора равенства, ==</a></li>
    <li><a><code class="python inline">__ne__(self, other)</code> Определяет поведение оператора неравенства, !=</a></li>
    <li><a><code class="python inline">__lt__(self, other)</code> Определяет поведение оператора меньше, <</a></li>
    <li><a><code class="python inline">__gt__(self, other)</code> Определяет поведение оператора больше, ></a></li>
    <li><a><code class="python inline">__le__(self, other)</code> Определяет поведение оператора меньше или равно, <=</a></li>
    <li><a><code class="python inline">__ge__(self, other)</code> Определяет поведение оператора больше или равно, >=</a></li>
    </ul>
    <h4>Унарные операторы и функции</h4>
    Унарные операторы и функции имеют только один операнд — отрицание, абсолютное значение, и так далее.
    <ul>
    <li><a><code class="python inline">__pos__(self)</code> Определяет поведение для унарного плюса (+some_object)
    <li><a><code class="python inline">__neg__(self)</code> Определяет поведение для отрицания(-some_object)
    <li><a><code class="python inline">__abs__(self)</code> Определяет поведение для встроенной функции abs().
    <li><a><code class="python inline">__invert__(self)</code> Определяет поведение для инвертирования оператором ~. Для объяснения что он делает смотри статью в Википедии о бинарных операторах.
    <li><a><code class="python inline">__round__(self, n)</code> Определяет поведение для встроенной функции round(). n это число знаков после запятой, до которого округлить.
    <li><a><code class="python inline">__floor__(self)</code> Определяет поведение для math.floor(), то есть, округления до ближайшего меньшего целого.
    <li><a><code class="python inline">__ceil__(self)</code> Определяет поведение для math.ceil(), то есть, округления до ближайшего большего целого.
    <li><a><code class="python inline">__trunc__(self)</code> Определяет поведение для math.trunc(), то есть, обрезания до целого.
    </ul>
      <h4>Обычные арифметические операторы</h4>
    <ul>
    <li><a><code class="python inline">__add__(self, other)</code> Сложение.
    <li><a><code class="python inline">__sub__(self, other)</code> Вычитание.
    <li><a><code class="python inline">__mul__(self, other)</code> Умножение.
    <li><a><code class="python inline">__floordiv__(self, other)</code> Целочисленное деление, оператор //.
    <li><a><code class="python inline">__div__(self, other)</code> Деление, оператор /.
    <li><a><code class="python inline">__truediv__(self, other)</code> Правильное деление. Заметьте, что это работает только когда используется from __future__ import division.
    <li><a><code class="python inline">__mod__(self, other)</code> Остаток от деления, оператор %.
    <li><a><code class="python inline">__divmod__(self, other)</code> Определяет поведение для встроенной функции divmod().
    <li><a><code class="python inline">__pow__</code> Возведение в степень, оператор **.
    <li><a><code class="python inline">__lshift__(self, other)</code> Двоичный сдвиг влево, оператор <<.
    <li><a><code class="python inline">__rshift__(self, other)</code> Двоичный сдвиг вправо, оператор >>.
    <li><a><code class="python inline">__and__(self, other)</code> Двоичное И, оператор &.
    <li><a><code class="python inline">__or__(self, other)</code> Двоичное ИЛИ, оператор |.
    <li><a><code class="python inline">__xor__(self, other)</code> Двоичный xor, оператор ^.
    </ul>
      <h4>Магические методы преобразования типов</h4>
    В Питоне множество магических методов, предназначенных для определения поведения для встроенных функций преобразования типов.
    <ul>
    <li><a><code class="python inline">__int__(self)</code> Преобразование типа в <a><code class="python inline">int</code>.
    <li><a><code class="python inline">__long__(self)</code> Преобразование типа в <a><code class="python inline">long</code>.
    <li><a><code class="python inline">__float__(self)</code> Преобразование типа в <a><code class="python inline">float</code>.
    <li><a><code class="python inline">__complex__(self)</code> Преобразование типа в комплексное число.
    <li><a><code class="python inline">__oct__(self)</code> Преобразование типа в восьмеричное число.
    <li><a><code class="python inline">__hex__(self)</code> Преобразование типа в шестнадцатеричное число.
    <li><a><code class="python inline">__index__(self)</code> Преобразование типа к <a><code class="python inline">int</code>, 
      когда объект используется в срезах (выражения вида <a><code class="python inline">[start:stop:step]</code>). Если вы определяете 
        свой числовой тип, который может использоваться как индекс списка, вы должны определить 
        <a><code class="python inline">__index__</code>.
    <li><a><code class="python inline">__trunc__(self)</code> Вызывается при 
      <a><code class="python inline">math.trunc(self)</code>. Должен вернуть своё значение, обрезанное до целочисленного типа 
        (обычно <a><code class="python inline">long)</code>.
    <li><a><code class="python inline">__coerce__(self, other)</code> Метод для реализации арифметики с операндами разных типов. 
      <a><code class="python inline">__coerce__</code> должен вернуть <a><code class="python inline">None</code> если преобразование типов невозможно. 
        Если преобразование возможно, он должен вернуть пару (кортеж из 2-х элементов) из 
        <a><code class="python inline">self</code> и <a><code class="python inline">other</code>, преобразованные к одному типу.
    </ul>
      <h4>Представление своих классов</h4>
    Часто бывает полезно представление класса в виде строки. В Питоне существует несколько методов, которые вы можете определить для настройки поведения встроенных функций при представлении вашего класса.
    <ul>
    <li><a><code class="python inline">__str__(self)</code> Определяет поведение функции 
      <a><code class="python inline">str()</code>, вызванной для экземпляра вашего класса.
    <li><a><code class="python inline">__repr__(self)</code> Определяет поведение функции 
      <a><code class="python inline">repr()</code>, вызванной для экземпляра вашего класса. 
        Главное отличие от <a><code class="python inline">str()</code> в целевой аудитории. 
          <a><code class="python inline">repr()</code> больше предназначен для машинно-ориентированного 
            вывода (более того, это часто должен быть валидный код на Питоне), а 
              <a><code class="python inline">str()</code> предназначен для чтения людьми.
    <li><a><code class="python inline">__unicode__(self)</code> Определяет поведение функции 
      <a><code class="python inline">unicode()</code>, вызванной для экземпляра вашего класса. 
        <a><code class="python inline">unicode()</code> похож на <a><code class="python inline">str()</code>, 
          но возвращает строку в юникоде. Если клиент вызывает <a><code class="python inline">str()</code> на \
            экземпляре вашего класса, а вы определили только <a><code class="python inline">__unicode__()</code>, 
              то это не будет работать. Постарайтесь всегда определять <a><code class="python inline">__str__()</code> 
                для случая, когда кто-то не имеет такой роскоши как юникод.
    <li><a><code class="python inline">__format__(self, formatstr)</code> Определяет поведение, когда экземпляр вашего 
      класса используется в форматировании строк нового стиля. Например, <a><code class="python inline">"Hello, {0:abc}!
        ".format(a)</code> приведёт к вызову a.<a><code class="python inline">__format__("abc")</code>. Это может быть полезно 
          для определения ваших собственных числовых или строковых типов, которым вы можете захотеть предоставить 
            какие-нибудь специальные опции форматирования.
    <li><a><code class="python inline">__hash__(self)</code> Определяет поведение функции 
      <a><code class="python inline">hash()</code>, вызванной для экземпляра вашего класса. Метод должен возвращать 
        целочисленное значение, которое будет использоваться для быстрого сравнения ключей в словарях. 
        Заметьте, что в таком случае обычно нужно определять и <a><code class="python inline">__eq__ тоже</code>. 
          Руководствуйтесь следующим правилом: a == b подразумевает <a><code class="python inline">hash(a) == hash(b)</code>.
    <li><a><code class="python inline">__nonzero__(self)</code> Определяет поведение функции 
      <a><code class="python inline">bool()</code>, вызванной для экземпляра вашего класса. Должна вернуть 
        <a><code class="python inline">True</code> или <a><code class="python inline">False</code>, в зависимости от того, 
          когда вы считаете экземпляр соответствующим <a><code class="python inline">True</code> или <a><code class="python inline">False</code>.
    <li><a><code class="python inline">__dir__(self)</code> Определяет поведение функции 
      <a><code class="python inline">dir()</code>, вызванной на экземпляре вашего класса. Этот метод должен возвращать 
        пользователю список атрибутов. Обычно, определение <a><code class="python inline">__dir__</code> не требуется, но может 
          быть жизненно важно для интерактивного использования вашего класса, если вы переопределили 
          <a><code class="python inline">__getattr__</code> или <a><code class="python inline">__getattribute__</code>.
    <li><a><code class="python inline">__sizeof__(self)</code> Определяет поведение функции 
      <a><code class="python inline">sys.getsizeof()</code>, вызванной на экземпляре вашего класса. Метод должен вернуть 
        размер вашего объекта в байтах.
    </ul>
      <h4>Магия контейнеров</h4>
    Магические методы, используемые контейнерами.
    <ul>
    <li><a><code class="python inline">__len__(self)</code> Возвращает количество элементов в контейнере. Часть протоколов для 
      изменяемого и неизменяемого контейнеров.
    <li><a><code class="python inline">__getitem__(self, key)</code> Определяет поведение при доступе к элементу, используя 
      синтаксис <a><code class="python inline">self[key]</code>. Тоже относится и к протоколу изменяемых и к протоколу 
        неизменяемых контейнеров. Должен выбрасывать соответствующие исключения: <a><code class="python inline">TypeError</code> 
          если неправильный тип ключа и <a><code class="python inline">KeyError</code> если ключу не соответствует никакого значения.
    <li><a><code class="python inline">__setitem__(self, key, value)</code> Определяет поведение при присваивании значения элементу, 
      используя синтаксис <a><code class="python inline">self[nkey] = value</code>. Часть протокола изменяемого контейнера. 
        Опять же, вы должны выбрасывать <a><code class="python inline">KeyError</code> и <a><code class="python inline">TypeError</code> в соответствующих случаях.
    <li><a><code class="python inline">__delitem__(self, key)</code> Определяет поведение при удалении элемента (то есть 
      <a><code class="python inline">del self[key])</code>. Это часть только протокола для изменяемого контейнера. 
        Вы должны выбрасывать соответствующее исключение, если ключ некорректен.
    <li><a><code class="python inline">__iter__(self)</code> Должен вернуть итератор для контейнера. 
      Итераторы возвращаются в множестве ситуаций, главным образом для встроенной функции <a><code class="python inline">iter()</code> 
        и в случае перебора элементов контейнера выражением <a><code class="python inline">for x in container:</code>. 
          Итераторы сами по себе объекты и они тоже должны определять метод 
          <a><code class="python inline">__iter__</code>, который возвращает <a><code class="python inline">self</code>.
    <li><a><code class="python inline">__reversed__(self)</code> Вызывается чтобы определить поведения для встроенной функции 
      <a><code class="python inline">reversed()</code>. Должен вернуть обратную версию последовательности. Реализуйте метод 
        только если класс упорядоченный, как список или кортеж.
    <li><a><code class="python inline">__contains__(self, item)</code> <a><code class="python inline">__contains__</code> 
      предназначен для проверки принадлежности элемента с помощью <a><code class="python inline">in</code> и 
        <a><code class="python inline">not in</code>. Вы спросите, почему же это не часть протокола последовательности? 
          Потому что когда <a><code class="python inline">__contains__</code> не определён, Питон просто перебирает всю 
            последовательность элемент за элементом и возвращает <a><code class="python inline">True</code> если находит нужный.
    <li><a><code class="python inline">__missing__(self, key)</code> <a><code class="python inline">__missing__</code> 
      используется при наследовании от <a><code class="python inline">dict</code> . Определяет поведение для для каждого 
        случая, когда пытаются получить элемент по несуществующему ключу (так, например, если у меня есть словарь d и я пишу 
        <a><code class="python inline">d["george"]</code> когда "george" не является ключом в словаре, вызывается d.
          <a><code class="python inline">__missing__("george")</code>).
    </ul>
    <h4>Построение дескрипторов</h4>
    Дескрипторы — это такие классы, с помощью которых можно добавить свою логику к событиям доступа (получение, 
    изменение, удаление) к атрибутам других объектов. Дескрипторы не подразумевается использовать сами по себе; 
    скорее, предполагается, что ими будут владеть какие-нибудь связанные с ними классы. Дескрипторы могут быть 
    полезны для построения объектно-ориентированных баз данных или классов, чьи атрибуты зависят друг от друга. 
    В частности, дескрипторы полезны при представлении атрибутов в нескольких системах исчисления или каких-либо 
    вычисляемых атрибутов (как расстояние от начальной точки до представленной атрибутом точки на сетке).<br />
    Чтобы класс стал дескриптором, он должен реализовать по крайней мере один метод из 
    <a><code class="python inline">__get__</code>, <a><code class="python inline">__set__</code> или <a><code class="python inline">__delete__</code>.
    <ul>
    <li><a><code class="python inline">__get__(self, instance, instance_class)</code> Определяет поведение при возвращении значения из 
      дескриптора. instance это объект, для чьего атрибута-дескриптора вызывается метод. <li><a><code class="python inline">owner</code> это тип (класс) объекта.
    <li><a><code class="python inline">__set__(self, instance, value)</code> Определяет поведение при изменении значения из дескриптора. 
      <a><code class="python inline">instance</code> это объект, для чьего атрибута-дескриптора вызывается метод. 
        <a><code class="python inline">value</code> это значение для установки в дескриптор.
    <li><a><code class="python inline">__delete__(self, instance)</code> Определяет поведение для удаления значения из дескриптора. 
      <a><code class="python inline">instance</code> это объект, владеющий дескриптором
    </ul>

    <a href="#" title="Вернуться вверх" class="buttonup"><img src="../images/up-arrow.png"></a>
    
    <!-- JavaScript код для плавной прокрутки наверх страницы -->
    <script>
      document.querySelector('.buttonup').addEventListener('click', function(e) {
        e.preventDefault();

        // Функция анимированной прокрутки
        function scrollToTop() {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          if (scrollTop > 0) {
            // Если еще не достигли верха страницы, анимированно прокручиваем вверх
            window.scrollTo(0, scrollTop - 500); // Уменьшаем scrollTop на 50 на каждом шаге
            requestAnimationFrame(scrollToTop); // Рекурсивно вызываем функцию
          } else {
            // Когда достигли верха страницы, останавливаем анимацию
            cancelAnimationFrame(scrollToTop);
          }
        }

        scrollToTop(); // Запускаем анимацию
      });
    </script>
</body>
